#!/usr/bin/env python3

import sys, socket, select, time, json, random

LAST = 0

def dump(thing, sock):
  sock.send(json.dumps(thing).encode())

def load(thing):
  return json.loads(thing.decode('utf-8'))

def set_last(x):
  global LAST
  LAST = x

def debug(sent, mid, type, src):
  print('[%s] %s msg: %s with type: %s for %s' % (sys.argv[1], sent, mid, type, src))

def follower_from_leader(leader, term):
  follower = Follower(leader.id, leader.replicas, leader.sock)
  follower.term = term
  follower.queue = leader.queue
  return follower

def format_json(src, dst, leader, type, mid):
  return {'src': src, 'dst': dst, 'leader': leader, 'type': type, 'MID': mid}

class Follower:
  def __init__(self, id, replicas, sock):
    self.leader = None
    self.id = id
    self.term = 0
    self.replicas = replicas
    self.sock = sock
    self.n = 1 + len(replicas)
    self.queue = []
    self.quorum = set()
    self.timeout = random.random() * 0.15 + 0.15

  def handle_msg(self, msg):
    debug('received', msg['MID'], msg['type'], msg['src'])
    if msg['type'] == 'get' or msg['type'] == 'put':
      return self.handle_client(msg)
    elif msg['type'] == 'election':
      return self.handle_election(msg)
    elif msg['type'] == 'vote':
      return self.handle_vote(msg)
    elif msg['type'] == 'heartbeat' and msg['src'] == self.leader:
      set_last(time.time())
      return self
    else:      
      return self

  def handle_vote(self, msg):
    if self.leader is not None:
      return self
    else:
      self.quorum.add(msg['src'])
      if len(self.quorum) > (self.n // 2):
        print('%s just became the leader!' % (self.id))
        return Leader(self)
      else:
        return self
      

  def handle_election(self, msg):
    term = int(msg['term'])
    if term > self.term:
      self.term = term
      self.leader = msg['src']
      self.timeout = 1
      dump(format_json(self.id, msg['src'], msg['src'], 'vote', msg['MID']), self.sock)
      debug('sent', msg['MID'], 'vote', msg['src'])
      return self
    else:
      debug('sent', msg['MID'], 'novote', msg['src'])
      return self

  def election(self):
    d = format_json(self.id, 'FFFF', self.id, 'election', 0)
    d['term'] = self.term
    dump(d, self.sock)

  def handle_client(self, msg):
    self.queue.append(msg)
    while self.leader is not None and self.queue:
      msg = self.queue.pop(0)
      src = msg['src']
      mid = msg['MID']
      dump(format_json(self.id, src, self.leader, 'redirect', mid), self.sock)
      debug('sent', mid, 'redirect', src)
    return self

  def handle_timeout(self):
    print('[%s] term: %s' % (self.id, self.term))
    if self.leader is None:
      self.timeout = random.random() * 0.15 + 0.15
      self.leader = self.id
    else:
      self.timeout = 1
      self.leader = None
      self.term += 1
      self.election()


class Leader:
  def __init__(self, candidate):
    self.leader = candidate.id
    self.id = candidate.id
    self.term = candidate.term
    self.replicas = candidate.replicas
    self.sock = candidate.sock
    self.n = candidate.n
    self.queue = candidate.queue
    self.quorum = set()
    self.timeout = 0.2

  def handle_msg(self, msg):
    debug('received', msg['MID'], msg['type'], msg['src'])
    if msg['type'] == 'get' or msg['type'] == 'put':
      return self.handle_client(msg)
    elif msg['type'] == 'election':
      return self.handle_election(msg)
    else:
      return self

  def handle_election(self, msg):
    term = msg['term']
    if int(term) > self.term:
      dump(format_json(self.id, msg['src'], msg['src'], 'vote', msg['MID']), self.sock)
      debug('sent', msg['MID'], 'vote', msg['src'])
      return follower_from_leader(self, term)
    else:
      debug('sent', msg['MID'], 'novote', msg['src'])
      return self

  def handle_client(self, msg):
    self.queue.append(msg)
    while self.queue:
      msg = self.queue.pop(0)
      if msg['type'] == 'put':
        self.put(msg)
      else:
        self.get(msg)
      debug('sent', msg['MID'], msg['type'], msg['src'])
    return self

  def handle_timeout(self):
    dump(format_json(self.id, 'FFFF', self.id, 'heartbeat', 0), self.sock)

  def put(self, msg):
    pass
  
  def get(self, msg):
    pass

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

shard = Follower(my_id, replica_ids, sock)
time.sleep(0.2)

while True:
  timestamp = time.time()
  if timestamp - LAST > shard.timeout:
    shard.handle_timeout()
    set_last(timestamp)

  ready = select.select([shard.sock], [], [], 0.1)[0]

  if shard.sock in ready:
    msg_raw = shard.sock.recv(32768)
		
    if len(msg_raw) > 0:
      msg = load(msg_raw)
      shard = shard.handle_msg(msg)
